# 网络

## http和https的区别

　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

## TCP和UDP的区别

- TCP是面向连接的 UDP是无连接的(即发送数据前不需要事先建立连接)
- TCP提供可靠的服务,通过TCP传输的数据无差错不丢失不重复且按序到达,UDP则是尽最大努力交付,不保证可靠交付
- TCP是面向字节流,UDP面向报文
- TCP是1对1  UDP是1对1也可以1对多
- TCP首部字节较大 为20字节,UDP首部字节为8字节

## 三次握手和四次挥手

我们先明确两个定义：
**1，client为数据发送方**
**2，server为数据接收方**

### 三次握手

好，下面进行三次握手的总结：
1，client想要向server发送数据，请求连接。这时client想服务器发送一个数据包，其中**同步位（SYN）**被置为1，**发送序号（SEQ）**=x，表明client申请TCP连接。
2，当server接收到了来自client的数据包时，解析发现同步位SYN为1，便知道client是想要建立TCP连接，于是将当前client的IP、端口之类的加入未连接队列中，并向client回复接受连接请求，向client发送数据包，其中**同步位SYN为1，并附带确认序号ACK=x+1**，**发送序号SEQ=y**，表明server已经准备好分配资源了，并向client发起连接请求，请求client为建立TCP连接而分配资源。
3，client向server回复一个**确认序号ACK=y+1**，并分配资源建立连接。server收到这个确认时也分配资源进行连接的建立

**问题来了**

- 为什么需要第三次握手，可以只进行两次握手吗？
- 第三次握手失败了怎么办？
- 三次握手有什么缺陷可以被黑客利用，用来对服务器进行攻击？
- 怎么防范这种攻击？


**1，为什么需要第三次握手？两次握手可以吗?**
答：如果没有第三次握手，可能会出现如下情况：

- 如果只有两次握手，那么server收到了client的**SYN=1的请求连接数据包**之后，便会分配资源并且向client发送一个**确认位ACK回复数据包**。
- 那么，如果在client与server建立连接的过程中，由于网络不顺畅等原因造成的通信链路中存在着残留数据包，即client向server发送的请求建立连接的数据包由于数据链路的拥塞或者质量不佳导致该连接请求数据包仍然在网络的链路中，这些残留数据包会造成如下危害
- **危害：**当client与server建立连接，数据发送完毕并且关闭TCP连接之后，如果链路中的残留数据包才到达server，那么server就会认为client重新发送了一次连接申请，便会回复ACK包并且分配资源。并且一直等待client发送数据，这就会造成**server的资源浪费。**

**2，第三次握手失败了怎么办？**
答：当client与server的第三次握手失败了之后，即client发送至server的确认建立连接报文段未能到达server，server在等待client回复ACK的过程中超时了，那么server会向client发送一个RTS报文段并进入关闭状态，即：并不等待client第三次握手的ACK包重传，直接关闭连接请求，这主要是为了防止泛洪攻击，即坏人伪造许多IP向server发送连接请求，从而将server的未连接队列塞满，浪费server的资源。

**3，三次握手有什么缺陷可以被黑客利用，用来对服务器进行攻击？**
答：黑客仿造IP大量的向server发送TCP连接请求报文包，从而将server的半连接队列（上文所说的未连接队列，即server收到连接请求SYN之后将client加入半连接队列中）占满，从而使得server拒绝其他正常的连接请求。即***拒绝服务攻击\***

**怎么防范这种攻击？**
1，缩短服务器接收客户端SYN报文之后的等待连接时间，即SYN timeout时间，也就是server接收到SYN报文段，到最后放弃此连接请求的超时时间，将SYN timeout设置的更低，便可以成倍的减少server的负荷，***但是过低的SYN timeout可能会影响正常的TCP连接的建立，一旦网络不通畅便可能导致client连接请求失败\***

**2，SYN cookie + SYN proxy 无缝集成（较好的解决方案）**

1. SYN cookie：当server接收到client的SYN之后，不立即分配资源，而是根据client发送过来的SYN包计算出一个cookie值，这个cookie值用来存储server返回给client的SYN+ACK数据包中的初始***，当client返回第三次握手的ACK包之后进行校验，如果校验成功则server分配资源，建立连接。
2. SYN proxy代理，作为server与client连接的代理，代替server与client建立三次握手的连接，同时SYN proxy与client建立好了三次握手连接之后，确保是正常的TCP连接，而不是TCP泛洪攻击，那么SYN proxy就与server建立三次握手连接，作为代理（网关？）来连通client与server。（类似v*n了解一下。）

### 四次挥手

下面对四次挥手的过程进行总结：
1，**（我客户端已经没有话跟你说了）** 当client所要发送的数据发送完毕之后（这里是接收到了来自于server方的，对于clien发送的最后一个数据包的收到确认ACK包之后），向server请求关闭连接，因此client向server发送一个FIN数据包，表明client数据发送完了，申请断开。并且自身进入***等待结束连接状态FIN_WAIT-1\***
2，**（我服务器知道你没话说了，但是你等等我，我不确定是否没话跟你说了，等我的回复）**当server收到了来自client的FIN请求包之后，向client回复一个确认报文ACK，同时进入关闭等待状态（CLOSE -WAIT），这时TCP连接的server便会向上层应用发送通知，表明client数据发送完毕，是否需要发送数据给client，这时TCP连接已经处于半关闭状态了，因为client已经没有数据要发送了。同时client收到了来自server的确认报文之后，便会进入***FIN-WAIT-2状态\***。
3，***（我服务器的上层应用也没话说了，咱们可以断开连接了）\*** TCP连接的server收到上层应用的指令表明没有数据要发送之后，会向client发送一个FIN请求数据包，其中确认位ACK=1，表明响应client的关闭连接请求，同时FIN=1表明server也准备好断开TCP连接了。
4，***（好的，那么咱们断开连接吧）***client收到了来自server的FIN数据包之后，知道server已经准备好断开连接了，于是向server发送一个确认数据包ACK，告诉server，可以关闭资源断开连接了。同时自身进入TIME-WAIT阶段，这个阶段将持续2MSL（MSL：报文在网络链路中的最长生命时长），在等待2MSL之后，client将会关闭资源。
5，serve日收到了来自于client的最后一个确认断开连接数据包之后便会直接进入TCP关闭状态，进行资源的回收。

那么问题来了：
**1，为什么要四次挥手**
答：前两次挥手是为了断开client至server的连接，后两次挥手是为了断开server至client的连接，如果没有第四次挥手，会出现如下状况：

1. server发送FIN数据包并携带ACK至client之后直接断开连接，如果client没有收到这个FIN数据包，那么client会一直处于等待关闭状态，这是为了确保TCP协议是面向连接安全有保证锝。
2. 上面解释了为什么不是三次挥手，同理，两次挥手也是不安全的。不能保证server与client都能正确关闭连接释放资源，而不会造成资源浪费。

**2，四次挥手之后client为什么还要等待2MSL的时间才释放资源关闭连接？**
答：

1. 如果client第四次挥手的确认报文段没有被server接收，那么server便会重发第三次挥手的FIN报文段，因此client要停留2MSL的时长来处理可能会重复收到的报文段。
2. 让之前建立的client-server通信过程中或者是挥手过程中由于网络不通畅产生的滞留报文段失效。如果不等待2MSL，那么建立新连接之后，可能会收到上一次连接的旧报文段，可能会造成混乱。

到这里TCP的三次握手四次挥手总结完了。上述总结纯属个人总结，由于能力有限造成的错漏请大家指出，我将会一一改正。



## GET和POST的区别

1、传送方式：get通过地址栏传输，post通过报文传输。GET请求只能进行url编码，而POST支持多种编码方式。

2、传送长度：get参数有长度限制（受限于url长度 2048个字符），而post无限制

3、GET产生一个TCP数据包；POST产生两个TCP数据包  header和body 所以POST会多用一些时间

4  get方式的安全性较Post方式要差些，因为参数直接暴露在URL上，所以不能用来传递敏感信息。包含机密信息的话，建议用Post数据提交方式；

5 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

6 GET请求会被浏览器主动cache GET请求参数会被完整保留在浏览器历史记录里，而POST不会，除非手动设置。GET在浏览器回退时是无害的，而POST会再次提交请求。

## HTTP状态码

**1 信息，服务器收到请求，需要请求者继续执行操作**

100 继续

101 切换协议

**2  成功，操作被成功接收并处理**

200 OK

201 已创建

202  已接受

203 非授权信息

204 无内容

205 重置内容

206 部分内容

**3  重定向，需要进一步的操作以完成请求**

300 多种选择

301 永久移动

302 临时移动

303 其他地址

304 未修改

305 使用代理

307 临时重定向

**4 客户端错误，请求包含语法错误或无法完成请求**

400 请求语法错误

401 身份认证

403 Forbidden 拒绝请求

404 NOt found 服务器无法根据客户端的请求找到资源（网页）

405 请求中的方法被禁止

406 服务器无法根据客户端请求的内容特性完成请求

407 请求要求代理的身份认证

408 服务器等待客户端发送的请求时间过长

409 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突

410 客户端请求的资源已经不存在

411 服务器无法处理客户端发送的不带Content-Length的请求信息

412 客户端请求信息的先决条件错误

413 由于请求的实体过大，服务器无法处理，因此拒绝请求。

414  请求的URI过长（URI通常为网址），服务器无法处理

415 服务器无法处理请求附带的媒体格式

416 客户端请求的范围无效

417 服务器无法满足Expect的请求头信息

**5 服务器错误，服务器在处理请求的过程中发生了错误**

500 服务器内部错误，无法完成请求

501  服务器不支持请求的功能，无法完成请求

502 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应

503 由于超载或系统维护，服务器暂时的无法处理客户端的请求。

504 充当网关或代理的服务器，未及时从远端服务器获取请求

505 服务器不支持请求的HTTP协议的版本，无法完成处理

## cookie和session的区别

1、数据存放位置不同：

cookie数据存放在用户的浏览器上，session数据放在服务器上。

2、安全程度不同：

cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session。

3、性能使用程度不同：

session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。

4、数据存储大小不同：

单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，而session则存储于服务端，浏览器对其没有限制。





##  sessionStorage、localStorage和cookie的区别
共同点：都是保存在浏览器端、且同源的 

区别： 

1、cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，

​      而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。

​      cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 

2、存储大小限制也不同

​	cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。

​    sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 

3、数据有效期不同

​	sessionStorage：仅在当前浏览器窗口关闭之前有效；

​	localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；

​	cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭 

4、作用域不同

sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；

localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的 

5、web Storage支持事件通知机制，可以将数据更新的通知发送给监听者 

6、web Storage的api接口使用更方便